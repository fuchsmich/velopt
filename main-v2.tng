--[[
beam system for shear analogy method
group velopt
--]]

-- include fem.tng file
dofile("femfunk.tng")

l = 7.2 -- length of beam [m]
h = tmath.Matrix({{0.06, 0.2, 0.1}}) -- thickness of part sections (top down) [m]
moe = tmath.Matrix({{19560e6, 1000e6, 1160e6}}) -- MoE [N/m²]
mos = tmath.Matrix({{moe[0]/2/(1+0.2), 15e6, 960e6}}) --MoS [N/m²]
rho = tmath.Matrix({{2272, 750, 470}}) --density [kg/m³]
costs = tmath.Matrix({{120, 200, 570}}) -- costs [€/m³]
weight_costs = .2 -- euro/kg

-- createStructure(h, l, moe, mos)
h_max = l/20
-- This function defines the objective
	function objective (x)
-- 	  local h = x
	  local costs_tot = (costs*x)[0] -- costs_tot [€/m²]	  
	  local weight_tot = (rho*x)[0] -- weight_tot [kg/m²]	
-- 	  if weight_tot*2.5*l > 7500 then -- above a weight of 7,5t, a bigger crane is needed at the construction site . that makes it 10times as expensive :)
-- 	     weight_costs = 100
-- 	  end
	  return costs_tot + weight_tot*weight_costs
	end

-- This function defines the constraints. Note that it returns an array		
	function constraints (x)
	  local h = x:Transpose()
	  u_max, sig = calcStructure(h, l, moe, mos, rho)
	  u_zul = l/400
	  local f_cd = 30e6    --compression concrete
	  local f_ctm = 5.96e6 --tension concrete
	  local k_mod = 0.8    --for NK1
	  local gam_M = 1.3    --security factor
	  local f_md = 24e6*k_mod/gam_M    --bending tension timber
-- 	  f_td = 10e6*    --compression timber
-- 	  local const=tmath.Matrix({{.08-h[1]}, {.02-h[2]}, {u-u_zul}, {0.02-h[0]}}) -- constraints for geometry and maximum deflection
	  sig_t = math.max(math.abs(sig[{2,0}]),math.abs(sig[{2,1}]))*1.4
	  sig_c = -sig[{0,0}]*1.4
	  local const=tmath.Matrix({{.03-h[0]}, {.05-h[1]}, {.03-h[2]}, {u_max-u_zul}, {sig_c-f_cd}, {sig_t-f_md}}) -- constraints for geometry and maximum deflection
	  return const
	end

-- The optimization algorithm is CONMIN by G. Vanderplaats
	nvariables = 3; nconstraints = 6
	ops=optimize.Conmin(nvariables, nconstraints)
	start=tmath.Matrix({{0.05}, {0.20}, {0.10}}); -- starting point: 20cm for velox, 10 cm for wood and 6cm concrete (fixed)
	ops:SetDesign(start)
	
-- Run optimization in reverse communication mode
-- This is an endless loop which is terminated when
-- the value "go_on" returned from Compute is equal to zero
	go_on=1
	while(1) do
-- Compute one step and check for termination
	  go_on=ops:Compute()
	  if (go_on==0) then break end

-- Compute objective
	  x = ops:GetDesign()
	  obj=objective(x)
	  ops:SetObjective(obj);

-- Compute constraints		
	  cons = constraints(x)
	  ops:SetConstraints(cons)
		
-- temp printing of solutions each step
	  sol = ops:GetDesign()
	  print("max. u:", u_max)
	  print("sig_c:", sig_c)
	  print("sig_t:", sig_t)
	  print("h_concrete      h_Velox        h_Wood", sol:Transpose())
	-- print("total hight", h[0]+sol[0]+sol[1])		
	end

-- Print optimization result
	sol = ops:GetDesign()
	h = sol:Transpose()
	-- print("h_zul", h_max)
	print("u_zul", u_zul)
	print("total height", h__tot(h))
-- 	print("deadload", dead_load(h, rho) "N/m²")
	print("max. u:", calcStructure(h, l, moe, mos, rho))
	print("total costs:", objective(x), "euro/m²")
	print(rho, h)
	print("weight:", dead_load(h, rho), "N/m²")
	print("h_concrete       h_Velox        h_Wood", sol:Transpose())
v = graphics.Visualize(30,30,1000,800, "Frame")
U2 = struct:GetAllDisplacements()
v:Vector(struct, U2, 2)
v:Draw(struct, 1)
-- tri = struct:Draw()
-- v = graph.Graph3D("frame")
-- v:Triangles(tri)
-- v:Render()
-- v:Autoscale()