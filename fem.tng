--[[
beam system for shear analogy method
(c) 2012 Michael Fuchs michfu@gmx.at
--]]

function createStructure(h, l, moe, mos)
  struct=fem.Structure("shearanalogybeam")

  local h_tot=0
  local EI_a = 0
  local EI_b = 0
  local GA_a = 0
  for i=0,2 do
    h_tot = h_tot + h[i]
  end
  local a=h[0]/2 + h[1] + h[2]/2
  --distance between first nodes (check if distance is big enough or at least bigger than 0)
  local dx=(l % a)/2
--   number of nodes 
  local n=math.floor(l/a)
  nodes = tmath.Matrix({
    {100, 0, 0, 0},
    {200, 0, -a, 0},
    {300, l+a, 0, 0}  --reference node
  })

  local x = dx
  local nnr = 1
  -- rest of nodes with distance a
  elements_a = tmath.Matrix(1,4)
  elements_b = tmath.Matrix(1,4)
  while x < l do
    nodes = nodes:AppendRows(tmath.Matrix({
      {100+nnr, x, 0, 0},
      {200+nnr, x, -a, 0}
    }))
--     connect nodes with constraint w_a = w_b
    if nnr == 1 then
      c=tmath.Matrix({{2, 100+nnr, 2, 1, 200+nnr, 2, 1}})
      elements_a = tmath.Matrix({{1999+nnr, 199+nnr, 200+nnr, 300}}) 
      elements_b = tmath.Matrix({{2999+nnr, 99+nnr, 100+nnr, 300}})
    else
      c=c:AppendRows(tmath.Matrix({{2, 100+nnr, 2, 1, 200+nnr, 2, 1}}))
      elements_a = elements_a:AppendRows(tmath.Matrix({{1999+nnr, 199+nnr, 200+nnr, 300}})) 
      elements_b = elements_b:AppendRows(tmath.Matrix({{2999+nnr, 99+nnr, 100+nnr, 300}}))
    end
--     elemente in balken a und b
    
    x = x + a
    nnr = nnr + 1
  end
--   nodes at the end of the beams
  nodes = nodes:AppendRows(tmath.Matrix({
    {100+nnr, x-a+dx, 0, 0},
    {200+nnr, x-a+dx, -a, 0},
  }))
    elements_a = elements_a:AppendRows(tmath.Matrix({{199+nnr, 199+nnr, 200+nnr, 300}}))
    elements_b = elements_b:AppendRows(tmath.Matrix({{99+nnr, 99+nnr, 100+nnr, 300}}))
  print(elements_a)
  struct:AddNodes(nodes)
--   print(c)
  struct:AddConstraints(c)

--   define supports
  struct:GetNode(100):SetAvailDof(tmath.Matrix({{0, 0, 0, 0, 0, 1}}))
  struct:GetNode(200):SetAvailDof(tmath.Matrix({{0, 0, 0, 0, 0, 1}}))
  struct:GetNode(100+nnr):SetAvailDof(tmath.Matrix({{1, 0, 0, 0, 0, 1}}))
  struct:GetNode(200+nnr):SetAvailDof(tmath.Matrix({{1, 0, 0, 0, 0, 1}}))
  struct:GetNode(300):SetAvailDof(tmath.Matrix({{0, 0, 0, 0, 0, 0}}))

  local EI_a=0
  local GA_a=0
  local ga_b=0 --temporary value for GA_b
  local h_above=0
  local f=1
  
  for i=0,2 do
    local z=h_tot/2 - h[i]/2 - h_above
    h_above=h_above+h[i]
    -- bending stiffness of beam a
    EI_a=EI_a + moe[i]*h[i]^2/12 
    -- shear stiffness of beam b
    GA_a=GA_a + mos[i]*h[i]
    -- bending stiffness of beam b (Steineranteile)
    EI_b=EI_b + moe[i]*h[i]*z^2
    if i==0 or i==2 then
      f = 2
    else
      f = 1
    end
    ga_b=ga_b + h[i]/(f*mos[i])
  end

  --   Ersatz shear stiffness of beam b
  GA_b=a^2/ga_b
  
--   beams have height of h_ab and width of 1m
  local h_ab=a/4
  local A_ab=h_ab
  local I_ab=h_ab^3/12
  for i=0,1 do
    local ss = struct:AddSection(i+1, "BEAM3D", 0)
    ss:SetData(tmath.Matrix({{A_ab, A_ab, A_ab, I_ab, I_ab, I_ab}}))
  end

--   	double G = E/2/(1+nu);
--   nu = 1/2*E/G - 1
  local moe_a=EI_a/I_ab
  local mos_a=GA_a/A_ab --could also be totally stiff
  local mm = struct:AddMaterial(1,"LINEAR_ELASTIC")
  mm.SetData(tmath.Matrix({{moe_a, 1/2*moe_a/mos_a-1, 1000}}))
  local moe_b=EI_b/I_ab
  local mos_b=GA_b/A_ab
  struct:AddMaterial(2,"LINEAR_ELASTIC")
  mm.SetData(tmath.Matrix({{moe_b, 1/2*mos_b/G_b-1, 1000}}))

  
-- add elements, first create Matrices with [number, start, end, reference point]
  struct:AddElements("BEAM3D", 1, 1, elements_a)
  struct:AddElements("BEAM3D", 2, 2, elements_b)

end


-- main starts here
l = 7.2
a = 11.8/2 + 15 + 6/2
h = tmath.Matrix({{0.06, 0.15, 0.118}}) -- thickness of part sections (top down) [m]
moe = tmath.Matrix({{19560, 1000, 10000}}) -- MoE [MN/mÂ²]
mos = tmath.Matrix({{moe[1]/2/(1+0.2), 15, 960}})
createStructure(h, l, moe, mos)
ww = graphics.Visualize(.05, .05, .6, .6, "Structure")
ww:Lighting(true)
ww:Perspective(true)
ww:SetAngles(10,30,0)
ww:Zoom(2)
ww:Draw(struct)

--[[
  createBeams(l,a)
  setElements(hi,[bi])
  setMaterials(Ei,Gi)
  setForces(F,g)
  getDisplacement(x)
  getStress(x,z)
--]]